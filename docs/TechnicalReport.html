<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Project summary, methodology, and findings placeholder">

<title>Technical Report – website</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">website</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Documentation.html"> 
<span class="menu-text">Documentation</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Tutorial.html"> 
<span class="menu-text">Tutorial</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./TechnicalReport.html" aria-current="page"> 
<span class="menu-text">Technical Report</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#executive-summary" id="toc-executive-summary" class="nav-link active" data-scroll-target="#executive-summary">Executive Summary</a></li>
  <li><a href="#project-context" id="toc-project-context" class="nav-link" data-scroll-target="#project-context">Project Context</a></li>
  <li><a href="#data-sources" id="toc-data-sources" class="nav-link" data-scroll-target="#data-sources">Data Sources</a></li>
  <li><a href="#methodology" id="toc-methodology" class="nav-link" data-scroll-target="#methodology">Methodology</a></li>
  <li><a href="#results-diagnostics" id="toc-results-diagnostics" class="nav-link" data-scroll-target="#results-diagnostics">Results &amp; Diagnostics</a></li>
  <li><a href="#discussion-next-steps" id="toc-discussion-next-steps" class="nav-link" data-scroll-target="#discussion-next-steps">Discussion &amp; Next Steps</a></li>
  <li><a href="#discussion-conclusion" id="toc-discussion-conclusion" class="nav-link" data-scroll-target="#discussion-conclusion">Discussion &amp; Conclusion</a>
  <ul class="collapse">
  <li><a href="#limitations" id="toc-limitations" class="nav-link" data-scroll-target="#limitations">Limitations</a></li>
  <li><a href="#next-steps" id="toc-next-steps" class="nav-link" data-scroll-target="#next-steps">Next steps</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Technical Report</h1>
</div>

<div>
  <div class="description">
    Project summary, methodology, and findings placeholder
  </div>
</div>


<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="executive-summary" class="level2">
<h2 class="anchored" data-anchor-id="executive-summary">Executive Summary</h2>
<p>In our preliminary project proposal, we expressed interest in examining snowfall patterns and exploring the potential to predict snowfall for skiers. However, after evaluating the data available to us, we found that a different set of questions could be addressed more effectively. Specifically, we became interested in how ski resort characteristics, such as size, elevation and geographic location, relate to annual snowfall. We also aim to identify which resorts across the United States and Canada receive the greatest snowfall. Understanding these patterns can help skiers make more informed decisions when planning trips and selecting destinations that maximize their time on the snow. After implementing a full cleaning pipeline and running exploratory data analysis (EDA), we identified clear trends: Western Canada and the Western U.S. have the highest average annual snowfall, Utah and Washington consistently exhibit the highest average annual snowfall, and high elevation is moderately associated with higher snowfall. These findings can support tourism planning, resort benchmarking, and ultimately help skiers decide where to ski.</p>
</section>
<section id="project-context" class="level2">
<h2 class="anchored" data-anchor-id="project-context">Project Context</h2>
<p>The motivation behind this project was to build a complete end-to-end data science workflow, including data collection, cleaning, analysis, and documentation. The main stakeholders are recreational skiers, tourism boards, and data science learners seeking insights into regional snowfall trends. Success was defined by the ability to (1) assemble a reproducible data pipeline, (2) clean inconsistencies in scraped weather/resort data, (3) generate clear EDA visualizations, and (4) interpret distributional patterns across states and provinces.</p>
</section>
<section id="data-sources" class="level2">
<h2 class="anchored" data-anchor-id="data-sources">Data Sources</h2>
<ul>
<li>_Primary dataset: A consolidated CSV of North American ski resorts containing columns for resort name, state/province, elevation statistics, acres, lift counts, and average annual snowfall. (Source: LINK!!!)</li>
<li>_Data access notes: All data was acquired through scraping Wikipedia. No licensing restrictions apply.</li>
</ul>
</section>
<section id="methodology" class="level2">
<h2 class="anchored" data-anchor-id="methodology">Methodology</h2>
<ol type="1">
<li><p><em>Data acquisition:</em> For the data collection phase of our project, we initially planned to use the OpenWeatherMap API to obtain historical weather information. However, during preliminary testing we encountered both logistical constraints, such as rate limits and incomplete data coverage, and ethical considerations related to adhering to API usage policies. As a result, we chose to adopt an alternative data source. We ultimately collected our data from the Comparison of North American Ski Resorts page on Wikipedia. To extract the relevant information, we used the BeautifulSoup library in Python, which allowed us to systematically parse the page’s HTML structure and retrieve variables of interest. This approach ensured that our data collection process remained reproducible, transparent, and aligned with course guidelines for web scraping.</p></li>
<li><p><em>Cleaning pipeline:</em> After web scraping the ski resort dataset from Wikipedia, the data required substantial data cleaning before the analysis could be performed. The original dataset included inconsistent column names, footnote markers, extra symbols, missing values, and non-numerical columns. The following steps were taken to prepare this dataset for analysis: Removed unnecessary columns The scraped data table included an extra column at the end that was not needed; it contained invaluable information related to our analysis. Therefore, this last column was removed. Renaming columns The remaining columns in the data table were renamed to standardized and descriptive variable names. Handling missing snowfall values Because snowfall is a central variable in this project, rows missing Average Annual Snowfall were removed. This prevented incomplete observations from biasing summary statistics and visualizations later in the process. Removing Wikipedia Footnotes and Brackets Many of the cells contained bracketed footnotes, which are common in Wikipedia tables. To remove these, we used regular expressions, which stripped out all bracketed content from every string column. This step was vital to our analysis because it ensured resort names, locations, and snowfall figures were clean and were ready to be analyzed. Cleaning Numeric columns Several of the numeric cells contained non-numeric characters such as commas, brackets, units, or parentheses. We created a function to extract only digits and decimal points and convert any of the values to floats. This allowed these columns to be used in statistical summaries and visualizations without type errors. Standardizing Categorical Columns Resort names, city names, and state/province fields were stripped of any leading or trailing whitespace. This prevented issues such as duplicate resort name that differ only by spacing. Final Dataset After doing all these cleaning steps, the dataset was ready to be analyzed. We saved the final dataset to a csv and then it was used for exploratory data analysis and visualizations.</p></li>
<li><p><em>Analysis workflow:</em> Exploratory Data Analysis (EDA) was performed to evaluate: -Distribution of average annual snowfall -Mean snowfall by state/province -Relationships between peak elevation and snowfall -Basic geographic summarization (regional snowfall trends)</p></li>
</ol>
<p>Charts included: -Boxplot of average snowfall by region -Bar charts ranking states by snowfall -Scatter plot comparing snowfall vs.&nbsp;elevation -Histograms and boxplots to visualize distributions</p>
<ol start="4" type="1">
<li><em>Tooling:</em> The project uses: -Python 3.11 -pandas, numpy, matplotlib, requests, seaborn, bs4, and streamlit -Development environment managed via uv -Tests written with pytest -A documented cleaning and analysis pipeline callable from the package root All code is fully reproducible via main.py or command-line execution.</li>
</ol>
</section>
<section id="results-diagnostics" class="level2">
<h2 class="anchored" data-anchor-id="results-diagnostics">Results &amp; Diagnostics</h2>
<p>We examined regional patterns in snowfall to determine which areas of North America receive the highest average levels. Our analysis shows that the Western United States and Western Canada experience substantially higher snowfall than other regions, while the Midwest and the Southeastern United States receive the least. These patterns are consistent with geographic and climatic expectations: western regions contain more mountainous terrain that promotes orographic precipitation, whereas southern regions have warmer temperatures due to their lower latitudes, resulting in reduced snowfall.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="plots/boxplot.png" class="img-fluid figure-img"></p>
<figcaption>Boxplot of Snowfall by Region</figcaption>
</figure>
</div>
<p>We were also curious about the correlation between certain numeric features of the data, total trails, total lifts, and average snowfall. We can see a high positive correlation between the number of trails and number of lifts. That makes sense, considering the structure of a ski resort. There is a moderate correlation between total trails and average snow fall.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="plots/correlation_heatmap.png" class="img-fluid figure-img"></p>
<figcaption>Correlation Heatmap</figcaption>
</figure>
</div>
<p>We looked at the distribution of snowfall for the top 20 ski resorts with the highest snowfall. This is left skewed where there are a few resorts that receive an unusually high level of snowfall on average.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="plots/distribution_snowfall.png" class="img-fluid figure-img"></p>
<figcaption>Distribution of Average Annual Snowfall</figcaption>
</figure>
</div>
<p>We then looked at the top 10 resorts that had the highest peak elevation. Nine out of the top 10 resorts were in Colorado. This was a really interesting finding. It seems to be that Colorado has the steepest terrain. The peak elevation was ~ 12,000 - 13,000 for these Colorado resorts. For these resorts, the average annual snowfall ranged from 235 to 450 inches. It seems that these resorts that have high elevation also have higher average annual snowfall.</p>
<p>After looking at the top 10 resorts for elevation, we were curious to see the top 10 resorts for average annual snowfall. The top resort was Alyeska Resort in Alaska with an average of 643 inches of snowfall each year. From these top 10 resorts, 3 of them were from Utah (Alta, Brighton, &amp; Snowbird).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="plots/annual_snowfall.png" class="img-fluid figure-img"></p>
<figcaption>Top 10 Resorts by Snowfall</figcaption>
</figure>
</div>
<p>To explore geographic differences in snowfall, we examined the Average Annual Snowfall (inches) column alongside the State/Province column. We created a bar plot that displays each state or province ranked by the snowfall values reported in our dataset. From this visualization, Utah shows the highest average annual snowfall in our dataset, followed by Washington and California. These rankings come directly from the average snowfall values listed for the resorts located in each region. This plot provides a quick snapshot of how snowfall conditions vary across different areas and highlights which regions tend to have resorts with the largest reported snowfall amounts.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="plots/snowfall_per_state.png" class="img-fluid figure-img"></p>
<figcaption>Average Snowfall per State</figcaption>
</figure>
</div>
<p>Next, we were interested to see how peak elevation and average snowfall are correlated. The scatterplot comparing average annual snowfall to peak elevation reveals a clear upward trend: resorts situated at higher elevations generally experience greater snowfall. While the relationship is not perfectly linear—there is still noticeable spread at each elevation level—the overall pattern suggests that elevation plays a meaningful role in increasing snowfall totals. Higher-altitude resorts likely benefit from colder temperatures and more favorable atmospheric conditions for sustained snowfall, which contributes to the positive trend observed in the plot. This pattern supports the idea that elevation is an important environmental factor influencing resort-level snow accumulation.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="plots/peak_elevation.png" class="img-fluid figure-img"></p>
<figcaption>Average Snowfall vs.&nbsp;Peak Elevation</figcaption>
</figure>
</div>
</section>
<section id="discussion-next-steps" class="level2">
<h2 class="anchored" data-anchor-id="discussion-next-steps">Discussion &amp; Next Steps</h2>
</section>
<section id="discussion-conclusion" class="level2">
<h2 class="anchored" data-anchor-id="discussion-conclusion">Discussion &amp; Conclusion</h2>
<p>Overall, our analysis provides a clear picture of how geography, terrain characteristics, and elevation shape snowfall patterns across North American ski resorts. The regional comparisons confirm well-established climatological expectations: western regions, particularly the Western United States and Western Canada, receive significantly more snowfall due to their mountainous landscapes and favorable weather systems. Meanwhile, regions such as the Midwest and Southeast receive considerably less snowfall, reflecting their lower elevations, warmer temperatures, and flatter topography. Our exploration of resort-level features also showed meaningful structural relationships within the data. The strong positive correlation between total trails and total lifts suggests that resort size and infrastructure tend to scale together. The moderate correlation between total trails and snowfall implies that resorts with higher snowfall may be able to support more extensive terrain, though this relationship is influenced by many other factors. The distributions of snowfall further highlight the variability between resorts. Most resorts fall within a typical range. However, there are some outliers - like Alyeska in Alaska. Elevation is a vital factor in explaining snowfall differences. Resorts that have the highest peak elevations tend to receive substantially more snowfall on average. The upward trend in the elevation–snowfall scatterplot supports the idea that colder temperatures and atmospheric conditions at higher altitudes lead to greater snow accumulation. This insight is reinforced by the fact that several top-elevation resorts also appear among the highest-snowfall locations. Skiers love some good snow. Therefore, skiers can use this analysis in determining where to ski that year, or even where to book a ski trip. By understanding which regions consistently receive the most snowfall—and how factors like elevation and resort size relate to snow conditions—skiers can better identify destinations that match their preferences.</p>
<section id="limitations" class="level3">
<h3 class="anchored" data-anchor-id="limitations">Limitations</h3>
<p>While this project can help skiers know where to ski and book ski trips, it still has several limitations. Because the dataset was sourced from Wikipedia, the accuracy and consistency of the reported snowfall values cannot be fully verified. Additionally, the table provides only average annual snowfall rather than historical records, which restricts our ability to examine trends over time or develop predictive models. Finally, the dataset includes only major ski resorts in North America, so our findings may not be generalizable to smaller resorts or those located in other regions.</p>
</section>
<section id="next-steps" class="level3">
<h3 class="anchored" data-anchor-id="next-steps">Next steps</h3>
<p>Recommended next steps: -Integrate multi-year snowfall trends to study variability -Add climate variables (temperature, latitude, precipitation) -Build predictive models to estimate snowfall or resort conditions -Enhance geographic analysis with mapping tools (e.g., Folium, geopandas)</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>